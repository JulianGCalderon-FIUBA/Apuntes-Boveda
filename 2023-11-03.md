Agrego el código base mostrado en la charla: [Code that Grows with Grace](https://www.youtube.com/watch?v=bj6EtLacsj8). El código está suelto en diapositivas, así que para que quede más prolijo lo deje en archivos y módulos distintos, tratando de ser lo más genérico posible. Me pareció que de esta forma iba a ser más fácil de testear. 

El resumen es:
- La estructura `matcher` guarda un canal de conexiones, lo que le permite llamar a una función `game` por cada dos conexiones que reciba.
- El tipo de dato `game` es una función que recibe dos conexiones. Si bien podría ser más prolijo usar una estructura en lugar de una función, me pareció que así podemos aprovechar varios patrones comunes en Go, que parten del paradigma funcional (una función es el bloque más pequeño que podría resolverlo, después podemos usar distintos patrones como el de _currying_)
  Un ejemplo de algo que está hecho de esta forma es el [HandlerFunc](https://pkg.go.dev/net/http#HandlerFunc) del paquete `net/http`. Por otro lado, también está el análogo [Handler](https://pkg.go.dev/net/http#Handler) que es una interfaz alrededor del `HandlerFunc`.
- En el `main` está el servidor TCP. Más adelante podríamos considerar guardarlo en una estructura y hacerlo más genérico para que pueda ser probado con tests unitarios (al igual que [Server](https://pkg.go.dev/net/http#Server), pero por ahora lo deje ahí.