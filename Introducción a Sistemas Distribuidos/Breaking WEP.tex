% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{\textbf{#1}}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={Breaking WEP},
  pdfauthor={Julián Gonzalez Calderón},
  pdfkeywords={wep, rc4, sistemas distribuidos},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{Breaking WEP}
\author{Julián Gonzalez Calderón}
\date{}

\begin{document}
\maketitle
\begin{abstract}
El objetivo de este trabajo práctico es el de investigar el protocolo
WEP y la razón de su vulnerabilidad
\end{abstract}

\hypertarget{quuxe9-es-wep}{%
\section{¿Qué es WEP?}\label{quuxe9-es-wep}}

El sistema \textbf{\emph{WEP}} es un sistema de cifrado opcional
incluido en el estándar \textbf{\emph{IEEE 802.11, edición 1999.}} Para
proteger la confidencialidad de los datos intercambiados a través de un
medio compartido.

Se utiliza una clave en común entre el remitente y el receptor. Se
presume que esta clave ya fue enviada de forma segura por otro medio,
independiente del \textbf{\emph{IEEE 802.11}}.

Debido a esta clave común, es un algoritmo simétrico, ya que la misma
clave se utiliza para encriptar o desencriptar.

\hypertarget{cuxf3mo-funciona-wep}{%
\section{¿Cómo funciona WEP?}\label{cuxf3mo-funciona-wep}}

Sea {} el segmento de datos que quiero enviar, el tamaño total del
segmento concatenado será de {}, en {}.

El algoritmo parte de una semilla de encriptación, que se obtendrá al
concatenar un vector de inicialización de {} que llamaremos {}, con la
clave compartida de {}, que llamaremos {}. El operador {⧺} denota
concatenación.

⧺

La semilla, de un total de {}, será introducida en el algoritmo de
encriptación \textbf{\emph{RC4,}} el cual devolverá un flujo de claves
de longitud {} que se utilizará para encriptar el segmento de datos.

Luego, se aplica una aplicación de \textbf{\emph{XOR}} entre el segmento
de datos y el flujo de claves para hallar el segmento cifrado.

Finalmente, se concatena el vector de inicialización {} al segmento
cifrado, y se envía a través del medio.

⧺

Cuando el receptor recibe el paquete, extrae el vector de inicialización
del segmento y lo introduce a \textbf{\emph{RC4}}, junto a la clave
compartida, para hallar el mismo flujo de claves que utilizó el
remitente.

Luego, se aplica una aplicación de \textbf{\emph{XOR}} entre el segmento
cifrado y el flujo de claves, obteniendo así el segmento original.

\hypertarget{cuxf3mo-funciona-rc4}{%
\section{¿Cómo funciona RC4?}\label{cuxf3mo-funciona-rc4}}

El protocolo \textbf{\emph{RC4}} consta de dos algoritmos,
extremadamente simples, que parten de una semilla dada. Definiremos {}
como la cantidad de permutaciones posibles de palabras de longitud {},
comúnmente, tendremos que {}.

\begin{enumerate}
\item
  \textbf{\emph{KSA - Key Scheduling Algorithm:}} Parte del vector de
  clave y crea un conjunto desordenado {} de valores entre {} y {}. Esto
  se obtiene creando una permutación identidad de valores entre {} y {}
  e intercambiando elementos a partir de la clave.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{for(i = 0 to N{-}1)}
\NormalTok{\{}
\NormalTok{   S[i] = i;}
\NormalTok{\}}
\NormalTok{j=0;}
\NormalTok{for(i = 0 to N{-}1)}
\NormalTok{\{}
\NormalTok{   j = ( j + S[i] + K[i mod keylength] ) mod N;}
\NormalTok{   intercambia S[i] and S[j];}
\NormalTok{\}}
\NormalTok{Copy}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{\emph{PRGA - Pseudo-Random Generation Algorithm:}} A partir
  del vector de claves y el conjunto permutación, va devolviendo valores
  del flujo de claves. Inicialmente, {}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i = (i + 1) mod N;}
\NormalTok{j = (j + S[i]) mod N;}
\NormalTok{intercambia S[i] and S[j];}
\NormalTok{t = (S[i] + S[j]) mod N;}
\NormalTok{Exponer valor de S[t];}
\NormalTok{Copy}
\end{Highlighting}
\end{Shaded}

  Cada valor expuesto por el algoritmo será un octeto del flujo de
  claves, este podrá tener cualquier longitud que se desea.
\end{enumerate}

\hypertarget{inseguridades-de-rc4}{%
\section{Inseguridades de RC4}\label{inseguridades-de-rc4}}

\hypertarget{debilidad-de-la-invariancia}{%
\subsection{Debilidad de la
Invariancia}\label{debilidad-de-la-invariancia}}

El primer algoritmo de, \textbf{\emph{KSA}}, expone dos inseguridades
significantes. La primera es la existencia de una gran clase de
\textbf{\emph{claves débiles}}, en las cuales una pequeña parte de la
llave determina un gran número de \textbf{\emph{bits}} de la permutación
inicial. Además, \textbf{\emph{PRGA}} traduce estos patrones en la
permutación inicial, en patrones en el prefijo del flujo de claves.

Esta afirmación permite distinguir fácilmente flujos de
\textbf{\emph{RC4}} de segmentos de datos aleatorios, debido a que las
palabras iniciales contienen patrones fácilmente reconocibles. Cuando
las claves son seleccionadas bajo una distribución uniforme, esta
inclinación se atenúa, pero aún permite la construcción de un
diferenciador eficiente. Además, los patrones se extienden a las
primeras decenas de palabras, por lo que la eficiencia del diferenciador
no disminuye si se descartan las primeras palabras.

\hypertarget{debilidad-de-clave-relacionada}{%
\subsection{Debilidad de clave
relacionada}\label{debilidad-de-clave-relacionada}}

La segunda debilidad está relacionada con la vulnerabilidad de las
claves, que aplica cuando parte de la clave presenta es expuesta al
atacante. Cuando la misma porción de clave secreta está presente en
diferentes valores expuestos, el atacante puede derivar la parte secreta
al analizar la palabra inicial del flujo de claves.

Para hacer esto, el algoritmo se aprovecha de la posibilidad de
encontrar claves tales que causen que el algoritmo entre en condición de
\textbf{\emph{resuelto}}.

Sea {} el vector permutación tras la iteración {} de la permutación,
definimos {}. Si para algún punto de la permutación, se cumple que {} es
mayor o igual que {}, entonces diremos que el algoritmo está en
condición de resuelto.

Cuando ocurre esto, aseguramos con probabilidad mayor a {} que los
elementos {} no volverán a participar en un intercambio. Luego, la
primera palabra del flujo de claves estará dado por {}.

Si no se cumple esto, entonces los elementos volverán a participar en
intercambios, haciendo que el valor resultante sea efectivamente
aleatorio. Esto implica que si repetimos este análisis para muchos
valores de escenarios resueltos, entonces el valor más probable será el
correcto.

\hypertarget{detalles-del-known-iv-attack}{%
\section{\texorpdfstring{Detalles del \textbf{\emph{Known IV
Attack}}}{Detalles del Known IV Attack}}\label{detalles-del-known-iv-attack}}

Debido a como funciona el algoritmo de \textbf{\emph{WEP}}, únicamente
estudiaremos el escenario en el que el vector de inicialización precede
a la clave secreta compartida, aunque ambas situaciones son vulnerables
al mismo tipo de ataque.

Sea {} el vector de inicialización conocido, de longitud {}, y {} la
clave secreta, de longitud {}, entonces construiremos la semilla para
\textbf{\emph{RC4}} como {⧺}, con longitud {}. Trataremos de derivar el
valor de la palabra {} de la clave secreta, esto es, la palabra {} de la
semilla. Para que este ataque sea posible, el atacante debe poder
obtener la primera palabra del flujo de claves. A esta primera palabra,
la denominaremos {}.

Si se cumple que {} y {}, entonces estaremos ante una condición resuelta
tras la ronda {} con una probabilidad relativamente alta: {}. Luego,
podremos tomar la suposición de que esto se cumplirá.

Por la condición de resuelto, tendremos que {} será cierto más del {} de
las veces. Al ser el valor más probable, lo asumiremos cierto. Luego,
podremos predecir la palabra buscada, a partir de la siguiente fórmula:

Algo importante a notar, es que este ataque requiere de una gran
cantidad de paquetes encriptados con distintos {}, por lo que si los
\textbf{\emph{hosts,}} en lugar de utilizar valores distintos cada vez,
alternan entre dos o una pequeña cantidad valores distintos, entonces el
ataque deja de funcionar.

Cabe notar que si ocurre esto, la red será susceptible a otro tipo de
ataques. Debido a que es posible obtener el flujo de claves a través del
cifrado y el valor desencriptado, si un ataque obtiene esto podrá
desencriptar fácilmente todos los paquetes provenientes del mismo vector
de inicialización, incluso sin conocer la clave.

\hypertarget{aplicaciuxf3n-del-ataque-en-wep}{%
\section{Aplicación del Ataque en
WEP}\label{aplicaciuxf3n-del-ataque-en-wep}}

El ataque consiste en observar selectivamente vectores {} tal que
podamos calcular la permutación en la iteración {} sin necesitar la
clave secreta. En este caso, {} será {}. Debemos previamente conocer la
primera palabra de flujo de claves.

Se necesitan aproximadamente {} vectores de la forma {}, donde {} indica
la cantidad de palabras conocidas de la clave secreta, y {} tomará
valores cualesquiera.

La elección de estos valores particulares, nos asegura que todas las
permutaciones, desde la inicial hasta la ronda {} son conocidos, lo que
nos permite trabajar con el resultado de la anterior sección. Para cada
vector válido observado, calcularemos sus permutaciones hasta la ronda
{}.

Si para alguno de los valores hallados, no se cumple la condición,
entonces lo descartamos. Para los valores que no descartamos, podemos
tomar las suposiciones indicadas en la anterior sección y derivar {} con
probabilidad {}. Al examinar una gran cantidad de resultados, un
atacante puede derivar la clave correctamente con probabilidad {}.

Debemos tener en cuenta que este ataque es válida para todos los ataques
que cumplan la condición propuesta, aunque estos no pertenezcan a la
forma mencionada.

\hypertarget{preparaciuxf3n-para-el-ataque}{%
\section{Preparación para el
Ataque}\label{preparaciuxf3n-para-el-ataque}}

Necesitamos dos elementos fundamentales para la ejecución de este
ataque. La primera es alguna tarjeta o adaptador de red que nos permita
escuchar y enviar paquetes de redes \textbf{\emph{802.11}}. A partir de
un programa conocido como \textbf{\emph{sniffer}} o analizador de
paquetes, podremos visualizar todos los paquetes que son enviados a
través del medio.

Estos programas configuran el adaptador de red en modo
\textbf{\emph{promiscuo}}. Este permite que los \textbf{\emph{frames}}
no destinados a nuestro dispositivo (a partir de la dirección
\textbf{\emph{MAC}}), no sean descartados.

El segundo elemento que necesitamos, es conocer la primera palabra de
los segmentos de datos enviados, sin encriptar. Al conocer esto, y con
el segmento cifrado, podremos determinar la primera palabra del flujo de
claves.

\hypertarget{obtenciuxf3n-de-paquetes}{%
\section{Obtención de Paquetes}\label{obtenciuxf3n-de-paquetes}}

Como vimos, el método requiere de, inicialmente, recolectar un gran
número de paquetes cifrados con distintos {}. Una opción es esperar el
tiempo necesario hasta recolectar los paquetes requeridos, pero existe
un truco para acelerar el proceso.

Otra opción es la de tomar un paquete ya perteneciente a la red
(encriptado con el mismo algoritmo), y reenviárselo repetidamente a uno
de los nodos de la red. Esto también aumentará la carga de la red.

Recordemos que el ataque es un ataque pasivo, por lo que este paso no es
necesario, pero altamente efectivo.

\hypertarget{resultados-del-ataque}{%
\section{Resultados del Ataque}\label{resultados-del-ataque}}

En \textbf{\emph{2001}}, \textbf{\emph{Fluhrer, Mantin y Shamir}}
tratarón de aplicar el ataque mencionado, para vulnerar una red con
\textbf{\emph{802.11}} autenticación \textbf{\emph{WEP}}.

A partir de lo mencionado, y con algunas modificaciones, pudieron
vulnerar \textbf{\emph{WEP}} utilizando un total de un millón de
paquetes.

\hypertarget{otras-inseguridades}{%
\section{Otras Inseguridades}\label{otras-inseguridades}}

El ataque mencionado no es la única forma de vulnerar este protocolo,
por ejemplo, veamos el ataque activo de inyección de paquetes.

El atacante debe conocer el contenido real de un paquete encriptado, de
esta forma, podremos obtener el flujo de claves correspondiente. Luego,
podremos encriptar cualquier paquete que nosotros queramos con este
flujo de claves. De esta forma, lograremos introducir paquetes malignos
en la red.

\hypertarget{evoluciuxf3n-de-wep}{%
\section{Evolución de WEP}\label{evoluciuxf3n-de-wep}}

A principios de 2001, se empezaron a identificar varias debilidades a
partir de analistas criptográficos. Unos meses más tarde, el
\textbf{IEEE} creó la corrección de seguridad \textbf{\emph{802.11i}}
para neutralizar esto. En \textbf{\emph{2004}}, finalmente, el estándar
\textbf{\emph{802.11i}}, también conocido como \textbf{\emph{WPA}}, fue
ratificado.

\end{document}
